import random as rd

# -------------------------------
# Ejercicio 1: Distribución simple p1=1/3, p2=2/3
# -------------------------------
def ejercicio1(n):
    p = [1/3, 2/3]
    X = []
    for _ in range(n):
        u = rd.random()
        if u < p[0]:
            X.append(1)
        else:
            X.append(2)
    # calcular proporción de valores = 1
    prop_1 = X.count(1)/len(X)
    print(f"n={n}, proporción de 1s: {prop_1:.4f}")

# Ejecutar para distintos n
ejercicio1(100)
ejercicio1(1000)
ejercicio1(10000)

def generar_valor(pmf):
    """
    pmf: lista de probabilidades que suman 1
    Devuelve un valor aleatorio X según la pmf
    """
    F = []           # Lista de probabilidades acumuladas
    acumulada = 0
    for i in range(len(pmf)):
        acumulada += pmf[i]
        F.append(acumulada)
    
    u = rd.random()  # Número aleatorio entre 0 y 1
    # Buscar el intervalo donde cae u
    for i in range(len(F)):
        if i == 0:
            if u < F[0]:
                return 1
        else:
            if F[i-1] <= u < F[i]:
                return i + 1

def ejercicio3(N):
    pmf = [0.3, 0.2, 0.35, 0.15]   # Probabilidades
    X = []

    # Generar N valores
    for i in range(N):
        valor = generar_valor(pmf)
        X.append(valor)

    # Contar frecuencias manualmente
    X_cuenta = []
    for i in range(len(pmf)):
        contador = 0
        for j in range(len(X)):
            if X[j] == i + 1:
                contador += 1
        X_cuenta.append(contador)

    # Calcular frecuencias relativas
    X_f_relativa = []
    for i in range(len(X_cuenta)):
        X_f_relativa.append(X_cuenta[i] / len(X))

    print("X generados:", X[:50], "...")  # Mostrar solo primeros 50 para no saturar
    print("Conteo:", X_cuenta)
    print("Frecuencias relativas:", X_f_relativa)

ejercicio3(10000)

def ejercicio4():
    n_cartas = 100
    cartas = []
    for i in range(1, n_cartas + 1):
        cartas.append(i)

    # Barajar cartas manualmente usando shuffle
    rd.shuffle(cartas)

    # Contar número de éxitos (carta i en posición i)
    exitos = 0
    for i in range(n_cartas):
        if cartas[i] == i + 1:
            exitos += 1

    print("Cartas barajadas:", cartas[:50], "...")  # Mostrar solo primeras 50
    print("Número total de éxitos:", exitos)
    return exitos

def ejercicio5(N_simulaciones=1000):
    resultados = []
    for i in range(N_simulaciones):
        exito = ejercicio4()
        resultados.append(exito)

    # Calcular esperanza
    suma = 0
    for i in range(len(resultados)):
        suma += resultados[i]
    esperanza = suma / len(resultados)

    # Calcular varianza
    suma_var = 0
    for i in range(len(resultados)):
        suma_var += (resultados[i] - esperanza) ** 2
    varianza = suma_var / len(resultados)

    print("Estimación de la esperanza:", esperanza)
    print("Estimación de la varianza:", varianza)

def permutacion_sucesiva(n):
    # Inicializamos permutación con primer elemento
    perm = [1]

    # Construimos la permutación sucesivamente
    for i in range(2, n + 1):
        perm.append(i)  # Añadimos elemento i al final

        # Elegimos posición aleatoria para intercambio
        j = rd.randint(0, i - 1)  # posiciones 0 a i-1
        temp = perm[i - 1]
        perm[i - 1] = perm[j]
        perm[j] = temp

    print("Permutación aleatoria de", n, "elementos:", perm)
    return perm

    def tasas_riesgo(pmf):
    """
    pmf: lista de probabilidades p1, p2, ..., pn
    Devuelve un valor X usando tasas discretas de riesgo
    """
    # Calcular tasas discretas t_n
    t = []
    for n in range(len(pmf)):
        suma = 0
        for j in range(n, len(pmf)):
            suma += pmf[j]
        tasa = pmf[n] / suma
        t.append(tasa)
    
    # Generar X usando el algoritmo
    X = 1
    while True:
        U = rd.random()
        if U < t[X-1]:
            break
        else:
            X += 1
    
    return X #17

    def tasas_riesgo_acumulada(tasas, N_simulaciones=10000):
    """
    tasas: lista de tasas discretas t1, t2, ..., tn
    Devuelve la lista de valores X generados según el algoritmo acumulativo
    """

    X = []

    for sim in range(N_simulaciones):
        S = 0  # Paso 1: inicializar S
        while True:
            # Paso 2: generar U y calcular Y geométrica
            U = rd.random()
            t1 = tasas[0]  # se usa t1 para generar Y geométrica
            Y = int(math.log(1 - U) / math.log(1 - t1)) + 1  # Ent() + 1
            # Paso 3: acumular S
            S += Y

            # Paso 4: generar otro U
            U2 = rd.random()

            # Paso 5: verificar tasa en S
            if S <= len(tasas):
                tS = tasas[S-1]
            else:
                tS = 1  # si S > n, se asume que se detiene seguro
            if U2 <= tS:
                X.append(S)
                break
            # Paso 6: repetir si no se cumple
    return X

# Ejemplo de uso
tasas = [0.1, 0.2, 0.3, 0.4]  # tasas discretas
X_gen = tasas_riesgo_acumulada(tasas, N_simulaciones=1000)

# Contar frecuencias manualmente
X_cuenta = []
for i in range(len(tasas)):
    contador = 0
    for j in range(len(X_gen)):
        if X_gen[j] == i + 1:
            contador += 1
    X_cuenta.append(contador)

# Frecuencias relativas
X_f_relativa = []
for i in range(len(X_cuenta)):
    X_f_relativa.append(X_cuenta[i] / len(X_gen))

print("X generados (primeros 50):", X_gen[:50], "...")
print("Conteo:", X_cuenta)
print("Frecuencias relativas:", X_f_relativa) #18 

import random as rd

def generar_X(pmf):
    F = []
    acumulada = 0
    for i in range(len(pmf)):
        acumulada += pmf[i]
        F.append(acumulada)
    U = rd.random()
    for i in range(len(F)):
        if i == 0:
            if U < F[0]:
                return 1
        else:
            if F[i-1] <= U < F[i]:
                return i + 1

pmf = [0.05, 0.15, 0.20, 0.25, 0.35]
X = []
N = 10000
for i in range(N):
    valor = generar_X(pmf)
    X.append(valor)

X_cuenta = []
for i in range(len(pmf)):
    contador = 0
    for j in range(len(X)):
        if X[j] == i + 1:
            contador += 1
    X_cuenta.append(contador)

X_f_relativa = []
for i in range(len(X_cuenta)):
    X_f_relativa.append(X_cuenta[i] / len(X))

print("Primeros 50 valores generados:", X[:50], "...")
print("Conteo:", X_cuenta)
print("Frecuencias relativas:", X_f_relativa)#16


import random as rd #13
import math

def binomial_pmf(n, p):
    pmf = []
    for k in range(n+1):
        coef = math.comb(n, k)
        pmf.append(coef * (p**k) * ((1-p)**(n-k)))
    return pmf

def generar_Y_transformada_inversa(n, p, k):
    pmf_X = binomial_pmf(n, p)
    pmf_Y = []
    for i in range(k, n+1):
        pmf_Y.append(pmf_X[i])
    suma = sum(pmf_Y)
    for i in range(len(pmf_Y)):
        pmf_Y[i] = pmf_Y[i] / suma
    F = []
    acumulada = 0
    for p in pmf_Y:
        acumulada += p
        F.append(acumulada)
    U = rd.random()
    for i in range(len(F)):
        if i == 0:
            if U < F[0]:
                return k
        else:
            if F[i-1] <= U < F[i]:
                return i + k

def generar_Y_rechazo(n, p, k):
    pmf_X = binomial_pmf(n, p)
    suma = sum(pmf_X[k:])
    while True:
        U1 = rd.random()
        U2 = rd.random()
        Y = 0
        acumulada = 0
        for i in range(n+1):
            acumulada += pmf_X[i]
            if U1 < acumulada:
                Y = i
                break
        if Y >= k:
            return Y

n = 10
p = 0.4
k = 5
N = 10000

Y1 = []
for i in range(N):
    Y1.append(generar_Y_transformada_inversa(n, p, k))

Y2 = []
for i in range(N):
    Y2.append(generar_Y_rechazo(n, p, k))

conteo_Y1 = []
for i in range(k, n+1):
    contador = 0
    for y in Y1:
        if y == i:
            contador += 1
    conteo_Y1.append(contador)

conteo_Y2 = []
for i in range(k, n+1):
    contador = 0
    for y in Y2:
        if y == i:
            contador += 1
    conteo_Y2.append(contador)

frecuencia_Y1 = []
for c in conteo_Y1:
    frecuencia_Y1.append(c / N)

frecuencia_Y2 = []
for c in conteo_Y2:
    frecuencia_Y2.append(c / N)

print("Frecuencias Y1 (transformada inversa):", frecuencia_Y1)
print("Frecuencias Y2 (aceptación-rechazo):", frecuencia_Y2)

